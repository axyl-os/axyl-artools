#!/bin/bash
#
# Copyright (C) 2018-19 artoo@artixlinux.org
# Copyright (C) 2018 Artix Linux Developers
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

. @libdir@/artools/util-pkg.sh

prepare_artools

patch_pkg(){
    local pkgpath="$1"
    local pkg=${pkgpath%/*}
    pkg=${pkg##*/}
    case $pkg in
        glibc)
            msg2 "Patching %s" "$pkg"
            sed -e 's|{locale,systemd/system,tmpfiles.d}|{locale,tmpfiles.d}|' \
                -e '/nscd.service/d' \
                -i $pkgpath/PKGBUILD
        ;;
        linux|linux-lts)
            msg2 "Patching %s" "$pkg"
            sed -e 's|KBUILD_BUILD_HOST=.*|KBUILD_BUILD_HOST=artixlinux|' -i $pkgpath/PKGBUILD
            sed -e 's|CONFIG_DEFAULT_HOSTNAME=.*|CONFIG_DEFAULT_HOSTNAME="artixlinux"|' \
                -i $pkgpath/config
        ;;
        bash)
            msg2 "Patching %s" "$pkg"
            sed -e 's|system.bash_logout)|system.bash_logout artix.bashrc)|' \
            -e "s|etc/bash.|etc/bash/|g" \
            -e 's|"$pkgdir/etc/skel/.bash_logout"|"$pkgdir/etc/skel/.bash_logout"\n  install -Dm644 artix.bashrc $pkgdir/etc/bash/bashrc.d/artix.bashrc|' \
            -i $pkgpath/PKGBUILD
            cd $pkgpath
                patch -Np 1 -i ${DATADIR}/patches/artix-bash.patch
                updpkgsums
            cd ../..
        ;;
        gstreamer|gst-plugins-*|licenses)
            msg2 "Patching %s" "$pkg"
            sed -e 's|https://www.archlinux.org/|https://www.artixlinux.org/|' \
                -e 's|(Arch Linux)|(Artix Linux)|' \
                -i $pkgpath/PKGBUILD
        ;;
    esac
}

pull_tree_arch(){
    cd ${TREE_DIR_ARCH}
    for tree in ${TREE_NAMES_ARCH[@]};do
        if [[ -d ${tree} ]];then
            cd ${tree}
            pull_tree "${tree}" "$(get_local_head)" "Arch"
            cd ..
        else
            clone_tree "${HOST_TREE_ARCH}" "${tree}" "Arch"
        fi
    done
}

pull_tree_artix(){
    local repos=("$1")
    cd ${TREE_DIR_ARTIX}
    for tree in ${repos[@]};do
        if [[ -d ${tree} ]];then
            config_tree "${tree}"
            cd ${tree}
            pull_tree "${tree}" "$(get_local_head)"
            cd ..
        else
            clone_tree "${HOST_TREE_ARTIX}" "${tree}"
            config_tree "${tree}"
        fi
    done
}

sync_pkg(){
    local rsync_args=(-aWxvci --progress --delete-before --no-R --no-implied-dirs)
    local src="$1" dest="$2"

    rsync "${rsync_args[@]}" $src/ $dest/
}

show_deps(){
    local src="$1"

    . $src/PKGBUILD 2>/dev/null

    [[ $arch == 'any' ]] && CARCH=any

    local archver=$(get_full_version)

    [[ -n ${pkgbase} ]] && msg2 "pkgbase: %s" "${pkgbase}"
    msg2 "pkgname: %s" "${pkgname[*]}"
    [[ -n $pkgdesc ]] && msg2 "pkgdesc: %s" "${pkgdesc}"
    msg2 "Arch Version: %s" "$archver"
    msg2 "arch: %s" "$CARCH"

    [[ -n ${makedepends[@]} ]] && msg2 "makedepends: %s" "${makedepends[*]}"
    [[ -n ${checkdepends[@]} ]] && msg2 "checkdepends: %s" "${checkdepends[*]}"
    [[ -n ${depends[@]} ]] && msg2 "depends: %s" "${depends[*]}"
    [[ -n ${optdepends[@]} ]] && msg2 "optdepends: %s" "${optdepends[@]}"
}

subrepo_new(){
    local group="${1:-$GROUP}" team="${2:-$TEAM}"
    local dest=${TREE_DIR_ARTIX}/$group/${PACKAGE}/trunk

    cd ${TREE_DIR_ARTIX}/$group

    msg2 "team: %s" "$team"
    msg2 "group: %s" "$group"

    local org=$(get_pkg_org "${PACKAGE}")

    create_repo "${PACKAGE}" "$org"

    add_repo_to_team "${PACKAGE}" "$org" "$team"

    subrepo_clone "${PACKAGE}" "$org"

    prepare_dir "$dest"

    commit_jenkins_files "${PACKAGE}"
}

get_group_packages(){
    local pkglist="${SYSCONFDIR}/pkglist.d/$1.list"

    local _space="s| ||g" _clean=':a;N;$!ba;s/\n/ /g' _com_rm="s|#.*||g"

    local pkgs=($(sed "$_com_rm" "$pkglist" | sed "$_space" | sed "$_clean"))

    local cases=
    for p in ${pkgs[@]};do
        cases=${cases:-}${cases:+|}${p}
    done
    echo $cases
}

get_group(){
    local pkg="$1" fallback="${2##*/}" tree=
    eval "case $pkg in
        $(get_group_packages kernel)) tree=packages-kernel ;;
        $(get_group_packages net)) tree=packages-net ;;
        $(get_group_packages python)) tree=packages-python ;;
        $(get_group_packages perl)) tree=packages-perl ;;
        $(get_group_packages ruby)) tree=packages-ruby ;;
        $(get_group_packages openrc)) tree=packages-openrc ;;
        $(get_group_packages runit)) tree=packages-runit ;;
        $(get_group_packages s6)) tree=packages-s6 ;;
        $(get_group_packages media)) tree=packages-media ;;
        $(get_group_packages xorg)) tree=packages-xorg ;;
        $(get_group_packages qt5)) tree=packages-qt5 ;;
        $(get_group_packages gtk)) tree=packages-gtk ;;
        $(get_group_packages java)) tree=packages-java ;;
        $(get_group_packages haskell)) tree=packages-haskell ;;
        $(get_group_packages devel)) tree=packages-devel ;;
        $(get_group_packages lxqt)) tree=packages-lxqt ;;
        $(get_group_packages cinnamon)) tree=packages-cinnamon ;;
        $(get_group_packages kde)) tree=packages-kde ;;
        $(get_group_packages gnome)) tree=packages-gnome ;;
        $(get_group_packages mate)) tree=packages-mate ;;
        $(get_group_packages xfce)) tree=packages-xfce ;;
        *) tree=$fallback ;;
    esac"
    echo $tree
}

get_team(){
    local repo="$1" team=
    case $repo in
        *testing*|*staging*)
            set_arch_repos false false false
            team=$(find_repo "$srcpath")
            team=${team%-*}
        ;;
        *) team=${repo%-*} ;;
    esac
    echo $team
}

from_arch(){
    cd ${TREE_DIR_ARTIX}

    local srcpath=$(find_pkg "${TREE_DIR_ARCH}" "${PACKAGE}")
    [[ -z $srcpath ]] && die "Package '%s' does not exist!" "${PACKAGE}"

    local repo=$(find_repo "$srcpath")

    archpath=$srcpath/repos/$repo
    local artixpath=$(find_pkg ${TREE_DIR_ARTIX} ${PACKAGE})
    local tree=${srcpath%/*}
    local tree=${tree##*/}
    local group=$(get_group "${PACKAGE}" "$tree")

    msg "repo: %s" "$repo"
    artixpath=$artixpath/trunk

    show_deps "$archpath"

    if [[ -f $artixpath/PKGBUILD ]];then

        . $artixpath/PKGBUILD 2>/dev/null
        local artixver=$(get_full_version)

        msg2 "Artix Version: %s" "$artixver"
    else
        artixpath=${TREE_DIR_ARTIX}/$group/${PACKAGE}/trunk
        subrepo_new "${group}" "$(get_team $repo)"
    fi

    msg "Sync (%s) from Arch [%s] to Artix [%s]" "${PACKAGE}" "${archpath##*archlinux/}" "${artixpath##*artixlinux/}"

    sync_pkg "$archpath" "$artixpath"
    patch_pkg "$artixpath"
}

view_build(){
    local archpath=$(find_pkg "${TREE_DIR_ARCH}" "${PACKAGE}")
    [[ -z $archpath ]] && die "Package '%s' does not exist!" "${PACKAGE}"
    local repo=$(find_repo "${archpath}")
    archpath=$archpath/repos/$repo
    msg2 "repo: %s" "$repo"
    show_deps "$archpath"
}

check_tree(){
    local archpath=$(find_pkg "${TREE_DIR_ARCH}" "${PACKAGE}")
    [[ -z $archpath ]] && die "Package '%s' does not exist!" "${PACKAGE}"
    local artixpath=$(find_pkg "${TREE_DIR_ARTIX}" ${PACKAGE})
    local group=${artixpath%/*}
    msg "group: %s" "${group##*/}"

    [[ -z $artixpath ]] && msg2 "exists: %s" "no"
    [[ -n $artixpath ]] && msg2 "exists: %s" "yes"
}

sync_repos(){
    ${sync_arch} && pull_tree_arch
    if ${sync_artix};then
        if ${sync_group}; then
            pull_tree_artix "${GROUP}"
        else
            pull_tree_artix "${TREE_NAMES_ARTIX[*]}"
        fi
    fi
}

load_makepkg_config

testing=true
staging=true
unstable=false

sync=false
sync_arch=true
sync_artix=true
import=false
view=false
createnew=false
sync_group=false
check=false

PACKAGE=''

TEAM='community'
GROUP=${TREE_NAMES_ARTIX[0]}

usage() {
    echo "Usage: ${0##*/} [options]"
    echo '    -p <pkg>      Package name'
    echo '    -t <team>     Team name (only with -n)'
    echo '                  Possible values: core,extra,community,multilib'
    echo "                  [default: ${TEAM}]"
    echo '    -g <group>    Group name, the superrepo (only with -n or -s)'
    echo "                  [default: ${GROUP}]"
    echo "    -s            Clone or pull repos"
    echo "    -a            Don't clone or pull arch repos"
    echo "    -b            Don't clone or pull artix repos"
    echo '    -i            Import a package from arch repos'
    echo '    -n            Make new remote subrepo and clone it'
    echo '    -v            Check if a package is in the artix tree(s)'
    echo '    -c            View package depends'
    echo '    -x            Exclude testing (only with -i)'
    echo '    -y            Exclude staging (only with -i)'
    echo '    -z            Include kde & gnome unstable (only with -i)'
    echo '    -h            This help'
    echo ''
    echo ''
    exit $1
}

orig_argv=("$0" "$@")

opts='p:t:g:sinabcvxyzh'

while getopts "${opts}" arg; do
    case "${arg}" in
        p) PACKAGE="$OPTARG" ;;
        t) TEAM="$OPTARG" ;;
        g) GROUP="$OPTARG"; sync_group=true ;;
        s) sync=true ;;
        a) sync_arch=false ;;
        b) sync_artix=false ;;
        i) import=true ;;
        n) createnew=true ;;
        c) check=true ;;
        v) view=true ;;
        x) testing=false ;;
        y) staging=false ;;
        z) unstable=true ;;
        h|?) usage 0 ;;
        *) echo "invalid argument '${arg}'"; usage 1 ;;
    esac
done

shift $(($OPTIND - 1))

prepare_dir "${TREE_DIR_ARTIX}"
prepare_dir "${TREE_DIR_ARCH}"

set_arch_repos "$testing" "$staging" "$unstable"

${sync} && sync_repos

${view} && view_build

${check} && check_tree

${import} && from_arch

${createnew} && subrepo_new
